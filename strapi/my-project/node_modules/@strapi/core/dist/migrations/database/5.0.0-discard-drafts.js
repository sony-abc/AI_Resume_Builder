"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const strapiUtils = require("@strapi/utils");
async function* getBatchToDiscard({
  db,
  trx,
  uid,
  batchSize = 1e3
}) {
  let offset = 0;
  let hasMore = true;
  while (hasMore) {
    const batch = await db.queryBuilder(uid).select(["id", "documentId", "locale"]).where({ publishedAt: { $ne: null } }).limit(batchSize).offset(offset).orderBy("id").transacting(trx).execute();
    if (batch.length < batchSize) {
      hasMore = false;
    }
    offset += batchSize;
    yield batch;
  }
}
const migrateUp = async (trx, db) => {
  for (const meta of db.metadata.values()) {
    const hasTable = await trx.schema.hasTable(meta.tableName);
    if (!hasTable) {
      continue;
    }
    const uid = meta.uid;
    const model = strapi.getModel(uid);
    const hasDP = strapiUtils.contentTypes.hasDraftAndPublish(model);
    if (!hasDP) {
      continue;
    }
    const discardDraft = async (entry) => strapi.documents(uid).discardDraft({ documentId: entry.documentId, locale: entry.locale });
    for await (const batch of getBatchToDiscard({ db, trx, uid: meta.uid })) {
      await strapiUtils.async.map(batch, discardDraft, { concurrency: 10 });
    }
  }
};
const discardDocumentDrafts = {
  name: "core::5.0.0-discard-drafts",
  async up(trx, db) {
    await migrateUp(trx, db);
  },
  async down() {
    throw new Error("not implemented");
  }
};
exports.discardDocumentDrafts = discardDocumentDrafts;
exports.getBatchToDiscard = getBatchToDiscard;
//# sourceMappingURL=5.0.0-discard-drafts.js.map
