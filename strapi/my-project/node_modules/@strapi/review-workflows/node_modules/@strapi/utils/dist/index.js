"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const _$1 = require("lodash");
const fp = require("lodash/fp");
const crypto = require("crypto");
const nodeMachineId = require("node-machine-id");
const yup$1 = require("yup");
const httpErrors = require("http-errors");
const pMap = require("p-map");
const execa = require("execa");
const preferredPM = require("preferred-pm");
const node_stream = require("node:stream");
const slugify = require("@sindresorhus/slugify");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
const ___default = /* @__PURE__ */ _interopDefault(_$1);
const yup__namespace = /* @__PURE__ */ _interopNamespace(yup$1);
const pMap__default = /* @__PURE__ */ _interopDefault(pMap);
const execa__default = /* @__PURE__ */ _interopDefault(execa);
const preferredPM__default = /* @__PURE__ */ _interopDefault(preferredPM);
const slugify__default = /* @__PURE__ */ _interopDefault(slugify);
const _ = require("lodash");
const dates$1 = require("date-fns");
const timeRegex = /^(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]{1,3})?$/;
const isDate = (v) => {
  return dates$1.isDate(v);
};
const parseTime = (value) => {
  if (isDate(value)) {
    return dates$1.format(value, "HH:mm:ss.SSS");
  }
  if (typeof value !== "string") {
    throw new Error(`Expected a string, got a ${typeof value}`);
  }
  const result = value.match(timeRegex);
  if (result === null) {
    throw new Error("Invalid time format, expected HH:mm:ss.SSS");
  }
  const [, hours, minutes, seconds, fraction = ".000"] = result;
  const fractionPart = _.padEnd(fraction.slice(1), 3, "0");
  return `${hours}:${minutes}:${seconds}.${fractionPart}`;
};
const parseDate = (value) => {
  if (isDate(value)) {
    return dates$1.format(value, "yyyy-MM-dd");
  }
  if (typeof value !== "string") {
    throw new Error(`Expected a string, got a ${typeof value}`);
  }
  try {
    const date = dates$1.parseISO(value);
    if (dates$1.isValid(date))
      return dates$1.format(date, "yyyy-MM-dd");
    throw new Error(`Invalid format, expected an ISO compatible date`);
  } catch (error) {
    throw new Error(`Invalid format, expected an ISO compatible date`);
  }
};
const parseDateTimeOrTimestamp = (value) => {
  if (isDate(value)) {
    return value;
  }
  if (typeof value !== "string") {
    throw new Error(`Expected a string, got a ${typeof value}`);
  }
  try {
    const date = dates$1.parseISO(value);
    if (dates$1.isValid(date))
      return date;
    const milliUnixDate = dates$1.parse(value, "T", /* @__PURE__ */ new Date());
    if (dates$1.isValid(milliUnixDate))
      return milliUnixDate;
    throw new Error(`Invalid format, expected a timestamp or an ISO date`);
  } catch (error) {
    throw new Error(`Invalid format, expected a timestamp or an ISO date`);
  }
};
const parseBoolean = (value, options) => {
  const { forceCast = false } = options;
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "string" || typeof value === "number") {
    if (["true", "t", "1", 1].includes(value)) {
      return true;
    }
    if (["false", "f", "0", 0].includes(value)) {
      return false;
    }
  }
  if (forceCast) {
    return Boolean(value);
  }
  throw new Error('Invalid boolean input. Expected "t","1","true","false","0","f"');
};
const parseType = (options) => {
  const { type, value, forceCast } = options;
  switch (type) {
    case "boolean":
      return parseBoolean(value, { forceCast });
    case "integer":
    case "biginteger":
    case "float":
    case "decimal": {
      return _.toNumber(value);
    }
    case "time": {
      return parseTime(value);
    }
    case "date": {
      return parseDate(value);
    }
    case "timestamp":
    case "datetime": {
      return parseDateTimeOrTimestamp(value);
    }
    default:
      return value;
  }
};
function envFn(key, defaultValue) {
  return ___default.default.has(process.env, key) ? process.env[key] : defaultValue;
}
function getKey(key) {
  return process.env[key] ?? "";
}
const utils = {
  int(key, defaultValue) {
    if (!___default.default.has(process.env, key)) {
      return defaultValue;
    }
    return parseInt(getKey(key), 10);
  },
  float(key, defaultValue) {
    if (!___default.default.has(process.env, key)) {
      return defaultValue;
    }
    return parseFloat(getKey(key));
  },
  bool(key, defaultValue) {
    if (!___default.default.has(process.env, key)) {
      return defaultValue;
    }
    return getKey(key) === "true";
  },
  json(key, defaultValue) {
    if (!___default.default.has(process.env, key)) {
      return defaultValue;
    }
    try {
      return JSON.parse(getKey(key));
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Invalid json environment variable ${key}: ${error.message}`);
      }
      throw error;
    }
  },
  array(key, defaultValue) {
    if (!___default.default.has(process.env, key)) {
      return defaultValue;
    }
    let value = getKey(key);
    if (value.startsWith("[") && value.endsWith("]")) {
      value = value.substring(1, value.length - 1);
    }
    return value.split(",").map((v) => {
      return ___default.default.trim(___default.default.trim(v, " "), '"');
    });
  },
  date(key, defaultValue) {
    if (!___default.default.has(process.env, key)) {
      return defaultValue;
    }
    return new Date(getKey(key));
  },
  /**
   * Gets a value from env that matches oneOf provided values
   * @param {string} key
   * @param {string[]} expectedValues
   * @param {string|undefined} defaultValue
   * @returns {string|undefined}
   */
  oneOf(key, expectedValues, defaultValue) {
    if (!expectedValues) {
      throw new Error(`env.oneOf requires expectedValues`);
    }
    if (defaultValue && !expectedValues.includes(defaultValue)) {
      throw new Error(`env.oneOf requires defaultValue to be included in expectedValues`);
    }
    const rawValue = env(key, defaultValue);
    return expectedValues.includes(rawValue) ? rawValue : defaultValue;
  }
};
const env = Object.assign(envFn, utils);
const SINGLE_TYPE = "singleType";
const COLLECTION_TYPE = "collectionType";
const ID_ATTRIBUTE$4 = "id";
const DOC_ID_ATTRIBUTE$4 = "documentId";
const PUBLISHED_AT_ATTRIBUTE$1 = "publishedAt";
const CREATED_BY_ATTRIBUTE$3 = "createdBy";
const UPDATED_BY_ATTRIBUTE$3 = "updatedBy";
const CREATED_AT_ATTRIBUTE = "createdAt";
const UPDATED_AT_ATTRIBUTE = "updatedAt";
const constants$1 = {
  ID_ATTRIBUTE: ID_ATTRIBUTE$4,
  DOC_ID_ATTRIBUTE: DOC_ID_ATTRIBUTE$4,
  PUBLISHED_AT_ATTRIBUTE: PUBLISHED_AT_ATTRIBUTE$1,
  CREATED_BY_ATTRIBUTE: CREATED_BY_ATTRIBUTE$3,
  UPDATED_BY_ATTRIBUTE: UPDATED_BY_ATTRIBUTE$3,
  CREATED_AT_ATTRIBUTE,
  UPDATED_AT_ATTRIBUTE,
  SINGLE_TYPE,
  COLLECTION_TYPE
};
const getTimestamps = (model) => {
  const attributes = [];
  if (fp.has(CREATED_AT_ATTRIBUTE, model.attributes)) {
    attributes.push(CREATED_AT_ATTRIBUTE);
  }
  if (fp.has(UPDATED_AT_ATTRIBUTE, model.attributes)) {
    attributes.push(UPDATED_AT_ATTRIBUTE);
  }
  return attributes;
};
const getCreatorFields = (model) => {
  const attributes = [];
  if (fp.has(CREATED_BY_ATTRIBUTE$3, model.attributes)) {
    attributes.push(CREATED_BY_ATTRIBUTE$3);
  }
  if (fp.has(UPDATED_BY_ATTRIBUTE$3, model.attributes)) {
    attributes.push(UPDATED_BY_ATTRIBUTE$3);
  }
  return attributes;
};
const getNonWritableAttributes = (model) => {
  if (!model)
    return [];
  const nonWritableAttributes = ___default.default.reduce(
    model.attributes,
    (acc, attr, attrName) => attr.writable === false ? acc.concat(attrName) : acc,
    []
  );
  return ___default.default.uniq([
    ID_ATTRIBUTE$4,
    DOC_ID_ATTRIBUTE$4,
    ...getTimestamps(model),
    ...nonWritableAttributes
  ]);
};
const getWritableAttributes = (model) => {
  if (!model)
    return [];
  return ___default.default.difference(Object.keys(model.attributes), getNonWritableAttributes(model));
};
const isWritableAttribute = (model, attributeName) => {
  return getWritableAttributes(model).includes(attributeName);
};
const getNonVisibleAttributes = (model) => {
  const nonVisibleAttributes = ___default.default.reduce(
    model.attributes,
    (acc, attr, attrName) => attr.visible === false ? acc.concat(attrName) : acc,
    []
  );
  return ___default.default.uniq([ID_ATTRIBUTE$4, DOC_ID_ATTRIBUTE$4, ...getTimestamps(model), ...nonVisibleAttributes]);
};
const getVisibleAttributes = (model) => {
  return ___default.default.difference(___default.default.keys(model.attributes), getNonVisibleAttributes(model));
};
const isVisibleAttribute = (model, attributeName) => {
  return getVisibleAttributes(model).includes(attributeName);
};
const getOptions = (model) => ___default.default.assign({ draftAndPublish: false }, ___default.default.get(model, "options", {}));
const hasDraftAndPublish = (model) => ___default.default.get(model, "options.draftAndPublish", false) === true;
const isDraft = (data, model) => hasDraftAndPublish(model) && ___default.default.get(data, PUBLISHED_AT_ATTRIBUTE$1) === null;
const isSingleType = ({ kind = COLLECTION_TYPE }) => kind === SINGLE_TYPE;
const isCollectionType = ({ kind = COLLECTION_TYPE }) => kind === COLLECTION_TYPE;
const isKind = (kind) => (model) => model.kind === kind;
const getStoredPrivateAttributes = (model) => fp.union(
  strapi?.config?.get("api.responses.privateAttributes", []) ?? [],
  fp.getOr([], "options.privateAttributes", model)
);
const getPrivateAttributes = (model) => {
  return ___default.default.union(
    getStoredPrivateAttributes(model),
    ___default.default.keys(___default.default.pickBy(model.attributes, (attr) => !!attr.private))
  );
};
const isPrivateAttribute = (model, attributeName) => {
  if (model?.attributes?.[attributeName]?.private === true) {
    return true;
  }
  return getStoredPrivateAttributes(model).includes(attributeName);
};
const isScalarAttribute = (attribute) => {
  return !["media", "component", "relation", "dynamiczone"].includes(attribute?.type);
};
const isMediaAttribute = (attribute) => attribute?.type === "media";
const isRelationalAttribute = (attribute) => attribute?.type === "relation";
const isComponentAttribute = (attribute) => ["component", "dynamiczone"].includes(attribute?.type);
const isDynamicZoneAttribute = (attribute) => attribute?.type === "dynamiczone";
const isMorphToRelationalAttribute = (attribute) => {
  return isRelationalAttribute(attribute) && attribute?.relation?.startsWith?.("morphTo");
};
const getComponentAttributes = (schema) => {
  return ___default.default.reduce(
    schema.attributes,
    (acc, attr, attrName) => {
      if (isComponentAttribute(attr))
        acc.push(attrName);
      return acc;
    },
    []
  );
};
const getScalarAttributes = (schema) => {
  return ___default.default.reduce(
    schema.attributes,
    (acc, attr, attrName) => {
      if (isScalarAttribute(attr))
        acc.push(attrName);
      return acc;
    },
    []
  );
};
const isTypedAttribute = (attribute, type) => {
  return ___default.default.has(attribute, "type") && attribute.type === type;
};
const getContentTypeRoutePrefix = (contentType) => {
  return isSingleType(contentType) ? ___default.default.kebabCase(contentType.info.singularName) : ___default.default.kebabCase(contentType.info.pluralName);
};
const contentTypes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  constants: constants$1,
  getComponentAttributes,
  getContentTypeRoutePrefix,
  getCreatorFields,
  getNonVisibleAttributes,
  getNonWritableAttributes,
  getOptions,
  getPrivateAttributes,
  getScalarAttributes,
  getTimestamps,
  getVisibleAttributes,
  getWritableAttributes,
  hasDraftAndPublish,
  isCollectionType,
  isComponentAttribute,
  isDraft,
  isDynamicZoneAttribute,
  isKind,
  isMediaAttribute,
  isMorphToRelationalAttribute,
  isPrivateAttribute,
  isRelationalAttribute,
  isScalarAttribute,
  isSingleType,
  isTypedAttribute,
  isVisibleAttribute,
  isWritableAttribute
}, Symbol.toStringTag, { value: "Module" }));
const { CREATED_BY_ATTRIBUTE: CREATED_BY_ATTRIBUTE$2, UPDATED_BY_ATTRIBUTE: UPDATED_BY_ATTRIBUTE$2 } = constants$1;
const setCreatorFields = ({ user, isEdition = false }) => (data) => {
  if (isEdition) {
    return fp.assoc(UPDATED_BY_ATTRIBUTE$2, user.id, data);
  }
  return fp.assign(data, {
    [CREATED_BY_ATTRIBUTE$2]: user.id,
    [UPDATED_BY_ATTRIBUTE$2]: user.id
  });
};
const createHook = () => {
  const state = {
    handlers: []
  };
  return {
    getHandlers() {
      return state.handlers;
    },
    register(handler) {
      state.handlers.push(handler);
      return this;
    },
    delete(handler) {
      state.handlers = fp.remove(fp.eq(handler), state.handlers);
      return this;
    },
    call() {
      throw new Error("Method not implemented");
    }
  };
};
const createAsyncSeriesHook = () => ({
  ...createHook(),
  async call(context) {
    for (const handler of this.getHandlers()) {
      await handler(context);
    }
  }
});
const createAsyncSeriesWaterfallHook = () => ({
  ...createHook(),
  async call(param) {
    let res = param;
    for (const handler of this.getHandlers()) {
      res = await handler(res);
    }
    return res;
  }
});
const createAsyncParallelHook = () => ({
  ...createHook(),
  async call(context) {
    const promises = this.getHandlers().map((handler) => handler(fp.cloneDeep(context)));
    return Promise.all(promises);
  }
});
const createAsyncBailHook = () => ({
  ...createHook(),
  async call(context) {
    for (const handler of this.getHandlers()) {
      const result = await handler(context);
      if (result !== void 0) {
        return result;
      }
    }
  }
});
const internals = {
  // Internal utils
  createHook
};
const hooks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createAsyncBailHook,
  createAsyncParallelHook,
  createAsyncSeriesHook,
  createAsyncSeriesWaterfallHook,
  internals
}, Symbol.toStringTag, { value: "Module" }));
const createProviderHooksMap = () => ({
  // Register events
  willRegister: createAsyncSeriesHook(),
  didRegister: createAsyncParallelHook(),
  // Delete events
  willDelete: createAsyncParallelHook(),
  didDelete: createAsyncParallelHook()
});
const providerFactory = (options = {}) => {
  const { throwOnDuplicates = true } = options;
  const state = {
    hooks: createProviderHooksMap(),
    registry: /* @__PURE__ */ new Map()
  };
  return {
    hooks: state.hooks,
    async register(key, item) {
      if (throwOnDuplicates && this.has(key)) {
        throw new Error(`Duplicated item key: ${key}`);
      }
      await state.hooks.willRegister.call({ key, value: item });
      state.registry.set(key, item);
      await state.hooks.didRegister.call({ key, value: fp.cloneDeep(item) });
      return this;
    },
    async delete(key) {
      if (this.has(key)) {
        const item = this.get(key);
        await state.hooks.willDelete.call({ key, value: fp.cloneDeep(item) });
        state.registry.delete(key);
        await state.hooks.didDelete.call({ key, value: fp.cloneDeep(item) });
      }
      return this;
    },
    get(key) {
      return state.registry.get(key);
    },
    getWhere(filters2 = {}) {
      const items = this.values();
      const filtersEntries = Object.entries(filters2);
      if (filtersEntries.length === 0) {
        return items;
      }
      return items.filter((item) => {
        return filtersEntries.every(([key, value]) => item[key] === value);
      });
    },
    values() {
      return Array.from(state.registry.values());
    },
    keys() {
      return Array.from(state.registry.keys());
    },
    has(key) {
      return state.registry.has(key);
    },
    size() {
      return state.registry.size;
    },
    async clear() {
      const keys = this.keys();
      for (const key of keys) {
        await this.delete(key);
      }
      return this;
    }
  };
};
const traverseEntity = async (visitor2, options, entity) => {
  const { path = { raw: null, attribute: null }, schema, getModel } = options;
  const traverseMorphRelationTarget = async (visitor22, path2, entry) => {
    const targetSchema = getModel(entry.__type);
    const traverseOptions = { schema: targetSchema, path: path2, getModel };
    return traverseEntity(visitor22, traverseOptions, entry);
  };
  const traverseRelationTarget = (schema2) => async (visitor22, path2, entry) => {
    const traverseOptions = { schema: schema2, path: path2, getModel };
    return traverseEntity(visitor22, traverseOptions, entry);
  };
  const traverseMediaTarget = async (visitor22, path2, entry) => {
    const targetSchemaUID = "plugin::upload.file";
    const targetSchema = getModel(targetSchemaUID);
    const traverseOptions = { schema: targetSchema, path: path2, getModel };
    return traverseEntity(visitor22, traverseOptions, entry);
  };
  const traverseComponent = async (visitor22, path2, schema2, entry) => {
    const traverseOptions = { schema: schema2, path: path2, getModel };
    return traverseEntity(visitor22, traverseOptions, entry);
  };
  const visitDynamicZoneEntry = async (visitor22, path2, entry) => {
    const targetSchema = getModel(entry.__component);
    const traverseOptions = { schema: targetSchema, path: path2, getModel };
    return traverseEntity(visitor22, traverseOptions, entry);
  };
  if (!fp.isObject(entity) || fp.isNil(schema)) {
    return entity;
  }
  const copy = fp.clone(entity);
  const visitorUtils = createVisitorUtils({ data: copy });
  const keys = Object.keys(copy);
  for (let i = 0; i < keys.length; i += 1) {
    const key = keys[i];
    const attribute = schema.attributes[key];
    if (fp.isNil(attribute)) {
      continue;
    }
    const newPath = { ...path };
    newPath.raw = fp.isNil(path.raw) ? key : `${path.raw}.${key}`;
    if (!fp.isNil(attribute)) {
      newPath.attribute = fp.isNil(path.attribute) ? key : `${path.attribute}.${key}`;
    }
    const visitorOptions = {
      data: copy,
      schema,
      key,
      value: copy[key],
      attribute,
      path: newPath,
      getModel
    };
    await visitor2(visitorOptions, visitorUtils);
    const value = copy[key];
    if (fp.isNil(value)) {
      continue;
    }
    if (isRelationalAttribute(attribute)) {
      const isMorphRelation = attribute.relation.toLowerCase().startsWith("morph");
      const method = isMorphRelation ? traverseMorphRelationTarget : traverseRelationTarget(getModel(attribute.target));
      if (fp.isArray(value)) {
        const res = new Array(value.length);
        for (let i2 = 0; i2 < value.length; i2 += 1) {
          res[i2] = await method(visitor2, newPath, value[i2]);
        }
        copy[key] = res;
      } else {
        copy[key] = await method(visitor2, newPath, value);
      }
      continue;
    }
    if (isMediaAttribute(attribute)) {
      if (fp.isArray(value)) {
        const res = new Array(value.length);
        for (let i2 = 0; i2 < value.length; i2 += 1) {
          res[i2] = await traverseMediaTarget(visitor2, newPath, value[i2]);
        }
        copy[key] = res;
      } else {
        copy[key] = await traverseMediaTarget(visitor2, newPath, value);
      }
      continue;
    }
    if (attribute.type === "component") {
      const targetSchema = getModel(attribute.component);
      if (fp.isArray(value)) {
        const res = new Array(value.length);
        for (let i2 = 0; i2 < value.length; i2 += 1) {
          res[i2] = await traverseComponent(visitor2, newPath, targetSchema, value[i2]);
        }
        copy[key] = res;
      } else {
        copy[key] = await traverseComponent(visitor2, newPath, targetSchema, value);
      }
      continue;
    }
    if (attribute.type === "dynamiczone" && fp.isArray(value)) {
      const res = new Array(value.length);
      for (let i2 = 0; i2 < value.length; i2 += 1) {
        res[i2] = await visitDynamicZoneEntry(visitor2, newPath, value[i2]);
      }
      copy[key] = res;
      continue;
    }
  }
  return copy;
};
const createVisitorUtils = ({ data }) => ({
  remove(key) {
    delete data[key];
  },
  set(key, value) {
    data[key] = value;
  }
});
const traverseEntity$1 = fp.curry(traverseEntity);
function importDefault(modName) {
  const mod = require(modName);
  return mod && mod.__esModule ? mod.default : mod;
}
const machineId = () => {
  try {
    const deviceId = nodeMachineId.machineIdSync();
    return deviceId;
  } catch (error) {
    const deviceId = crypto.randomUUID();
    return deviceId;
  }
};
const formatYupInnerError = (yupError) => ({
  path: fp.toPath(yupError.path),
  message: yupError.message,
  name: yupError.name
});
const formatYupErrors = (yupError) => ({
  errors: fp.isEmpty(yupError.inner) ? [formatYupInnerError(yupError)] : yupError.inner.map(formatYupInnerError),
  message: yupError.message
});
class ApplicationError extends Error {
  name;
  details;
  message;
  constructor(message = "An application error occured", details = {}) {
    super();
    this.name = "ApplicationError";
    this.message = message;
    this.details = details;
  }
}
class ValidationError extends ApplicationError {
  constructor(message, details) {
    super(message, details);
    this.name = "ValidationError";
  }
}
class YupValidationError extends ValidationError {
  constructor(yupError, message) {
    super("Validation");
    const { errors: errors2, message: yupMessage } = formatYupErrors(yupError);
    this.message = message || yupMessage;
    this.details = { errors: errors2 };
  }
}
class PaginationError extends ApplicationError {
  constructor(message = "Invalid pagination", details) {
    super(message, details);
    this.name = "PaginationError";
    this.message = message;
  }
}
class NotFoundError extends ApplicationError {
  constructor(message = "Entity not found", details) {
    super(message, details);
    this.name = "NotFoundError";
    this.message = message;
  }
}
class ForbiddenError extends ApplicationError {
  constructor(message = "Forbidden access", details) {
    super(message, details);
    this.name = "ForbiddenError";
    this.message = message;
  }
}
class UnauthorizedError extends ApplicationError {
  constructor(message = "Unauthorized", details) {
    super(message, details);
    this.name = "UnauthorizedError";
    this.message = message;
  }
}
class RateLimitError extends ApplicationError {
  constructor(message = "Too many requests, please try again later.", details) {
    super(message, details);
    this.name = "RateLimitError";
    this.message = message;
    this.details = details || {};
  }
}
class PayloadTooLargeError extends ApplicationError {
  constructor(message = "Entity too large", details) {
    super(message, details);
    this.name = "PayloadTooLargeError";
    this.message = message;
  }
}
class PolicyError extends ForbiddenError {
  constructor(message = "Policy Failed", details) {
    super(message, details);
    this.name = "PolicyError";
    this.message = message;
    this.details = details || {};
  }
}
class NotImplementedError extends ApplicationError {
  constructor(message = "This feature is not implemented yet", details) {
    super(message, details);
    this.name = "NotImplementedError";
    this.message = message;
  }
}
const errors = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ApplicationError,
  ForbiddenError,
  HttpError: httpErrors.HttpError,
  NotFoundError,
  NotImplementedError,
  PaginationError,
  PayloadTooLargeError,
  PolicyError,
  RateLimitError,
  UnauthorizedError,
  ValidationError,
  YupValidationError
}, Symbol.toStringTag, { value: "Module" }));
const handleYupError = (error, errorMessage) => {
  throw new YupValidationError(error, errorMessage);
};
const defaultValidationParam = { strict: true, abortEarly: false };
const validateYupSchema = (schema, options = {}) => async (body, errorMessage) => {
  try {
    const optionsWithDefaults = fp.defaults(defaultValidationParam, options);
    const result = await schema.validate(body, optionsWithDefaults);
    return result;
  } catch (e) {
    if (e instanceof yup__namespace.ValidationError) {
      handleYupError(e, errorMessage);
    }
    throw e;
  }
};
const validateYupSchemaSync = (schema, options = {}) => (body, errorMessage) => {
  try {
    const optionsWithDefaults = fp.defaults(defaultValidationParam, options);
    return schema.validateSync(body, optionsWithDefaults);
  } catch (e) {
    if (e instanceof yup__namespace.ValidationError) {
      handleYupError(e, errorMessage);
    }
    throw e;
  }
};
const GROUP_OPERATORS = ["$and", "$or"];
const WHERE_OPERATORS = [
  "$not",
  "$in",
  "$notIn",
  "$eq",
  "$eqi",
  "$ne",
  "$nei",
  "$gt",
  "$gte",
  "$lt",
  "$lte",
  "$null",
  "$notNull",
  "$between",
  "$startsWith",
  "$endsWith",
  "$startsWithi",
  "$endsWithi",
  "$contains",
  "$notContains",
  "$containsi",
  "$notContainsi",
  // Experimental, only for internal use
  "$jsonSupersetOf"
];
const CAST_OPERATORS = [
  "$not",
  "$in",
  "$notIn",
  "$eq",
  "$ne",
  "$gt",
  "$gte",
  "$lt",
  "$lte",
  "$between"
];
const ARRAY_OPERATORS = ["$in", "$notIn", "$between"];
const OPERATORS = {
  where: WHERE_OPERATORS,
  cast: CAST_OPERATORS,
  group: GROUP_OPERATORS,
  array: ARRAY_OPERATORS
};
const OPERATORS_LOWERCASE = Object.fromEntries(
  Object.entries(OPERATORS).map(([key, values]) => [
    key,
    values.map((value) => value.toLowerCase())
  ])
);
const isObjKey = (key, obj) => {
  return key in obj;
};
const isOperatorOfType = (type, key, ignoreCase = false) => {
  if (ignoreCase) {
    return OPERATORS_LOWERCASE[type]?.includes(key.toLowerCase()) ?? false;
  }
  if (isObjKey(type, OPERATORS)) {
    return OPERATORS[type]?.includes(key) ?? false;
  }
  return false;
};
const isOperator = (key, ignoreCase = false) => {
  return Object.keys(OPERATORS).some((type) => isOperatorOfType(type, key, ignoreCase));
};
const { ID_ATTRIBUTE: ID_ATTRIBUTE$3, DOC_ID_ATTRIBUTE: DOC_ID_ATTRIBUTE$3, PUBLISHED_AT_ATTRIBUTE } = constants$1;
class InvalidOrderError extends Error {
  constructor() {
    super();
    this.message = "Invalid order. order can only be one of asc|desc|ASC|DESC";
  }
}
class InvalidSortError extends Error {
  constructor() {
    super();
    this.message = "Invalid sort parameter. Expected a string, an array of strings, a sort object or an array of sort objects";
  }
}
function validateOrder(order) {
  if (!fp.isString(order) || !["asc", "desc"].includes(order.toLocaleLowerCase())) {
    throw new InvalidOrderError();
  }
}
const convertCountQueryParams = (countQuery) => {
  return parseType({ type: "boolean", value: countQuery });
};
const convertOrderingQueryParams = (ordering) => {
  return ordering;
};
const isPlainObject = (value) => ___default.default.isPlainObject(value);
const isStringArray$3 = (value) => fp.isArray(value) && value.every(fp.isString);
const createTransformer = ({ getModel }) => {
  const convertSortQueryParams = (sortQuery) => {
    if (typeof sortQuery === "string") {
      return convertStringSortQueryParam(sortQuery);
    }
    if (isStringArray$3(sortQuery)) {
      return sortQuery.flatMap((sortValue) => convertStringSortQueryParam(sortValue));
    }
    if (Array.isArray(sortQuery)) {
      return sortQuery.map((sortValue) => convertNestedSortQueryParam(sortValue));
    }
    if (isPlainObject(sortQuery)) {
      return convertNestedSortQueryParam(sortQuery);
    }
    throw new InvalidSortError();
  };
  const convertStringSortQueryParam = (sortQuery) => {
    return sortQuery.split(",").map((value) => convertSingleSortQueryParam(value));
  };
  const convertSingleSortQueryParam = (sortQuery) => {
    if (!sortQuery) {
      return {};
    }
    if (!fp.isString(sortQuery)) {
      throw new Error("Invalid sort query");
    }
    const [field, order = "asc"] = sortQuery.split(":");
    if (field.length === 0) {
      throw new Error("Field cannot be empty");
    }
    validateOrder(order);
    return ___default.default.set({}, field, order);
  };
  const convertNestedSortQueryParam = (sortQuery) => {
    const transformedSort = {};
    for (const field of Object.keys(sortQuery)) {
      const order = sortQuery[field];
      if (isPlainObject(order)) {
        transformedSort[field] = convertNestedSortQueryParam(order);
      } else if (typeof order === "string") {
        validateOrder(order);
        transformedSort[field] = order;
      } else {
        throw Error(`Invalid sort type expected object or string got ${typeof order}`);
      }
    }
    return transformedSort;
  };
  const convertStartQueryParams = (startQuery) => {
    const startAsANumber = ___default.default.toNumber(startQuery);
    if (!___default.default.isInteger(startAsANumber) || startAsANumber < 0) {
      throw new Error(`convertStartQueryParams expected a positive integer got ${startAsANumber}`);
    }
    return startAsANumber;
  };
  const convertLimitQueryParams = (limitQuery) => {
    const limitAsANumber = ___default.default.toNumber(limitQuery);
    if (!___default.default.isInteger(limitAsANumber) || limitAsANumber !== -1 && limitAsANumber < 0) {
      throw new Error(`convertLimitQueryParams expected a positive integer got ${limitAsANumber}`);
    }
    if (limitAsANumber === -1) {
      return void 0;
    }
    return limitAsANumber;
  };
  const convertPageQueryParams = (page) => {
    const pageVal = fp.toNumber(page);
    if (!fp.isInteger(pageVal) || pageVal <= 0) {
      throw new PaginationError(
        `Invalid 'page' parameter. Expected an integer > 0, received: ${page}`
      );
    }
    return pageVal;
  };
  const convertPageSizeQueryParams = (pageSize, page) => {
    const pageSizeVal = fp.toNumber(pageSize);
    if (!fp.isInteger(pageSizeVal) || pageSizeVal <= 0) {
      throw new PaginationError(
        `Invalid 'pageSize' parameter. Expected an integer > 0, received: ${page}`
      );
    }
    return pageSizeVal;
  };
  const validatePaginationParams = (page, pageSize, start, limit) => {
    const isPagePagination = !fp.isNil(page) || !fp.isNil(pageSize);
    const isOffsetPagination = !fp.isNil(start) || !fp.isNil(limit);
    if (isPagePagination && isOffsetPagination) {
      throw new PaginationError(
        "Invalid pagination attributes. You cannot use page and offset pagination in the same query"
      );
    }
  };
  class InvalidPopulateError extends Error {
    constructor() {
      super();
      this.message = "Invalid populate parameter. Expected a string, an array of strings, a populate object";
    }
  }
  const convertPopulateQueryParams = (populate2, schema, depth = 0) => {
    if (depth === 0 && populate2 === "*") {
      return true;
    }
    if (typeof populate2 === "string") {
      return populate2.split(",").map((value) => ___default.default.trim(value));
    }
    if (Array.isArray(populate2)) {
      return ___default.default.uniq(
        populate2.flatMap((value) => {
          if (typeof value !== "string") {
            throw new InvalidPopulateError();
          }
          return value.split(",").map((value2) => ___default.default.trim(value2));
        })
      );
    }
    if (___default.default.isPlainObject(populate2)) {
      return convertPopulateObject(populate2, schema);
    }
    throw new InvalidPopulateError();
  };
  const hasFragmentPopulateDefined = (populate2) => {
    return typeof populate2 === "object" && "on" in populate2 && !fp.isNil(populate2.on);
  };
  const convertPopulateObject = (populate2, schema) => {
    if (!schema) {
      return {};
    }
    const { attributes } = schema;
    return Object.entries(populate2).reduce((acc, [key, subPopulate]) => {
      if (___default.default.isBoolean(subPopulate)) {
        return { ...acc, [key]: subPopulate };
      }
      const attribute = attributes[key];
      if (!attribute) {
        return acc;
      }
      const isAllowedAttributeForFragmentPopulate = isDynamicZoneAttribute(attribute) || isMorphToRelationalAttribute(attribute);
      if (isAllowedAttributeForFragmentPopulate && hasFragmentPopulateDefined(subPopulate)) {
        return {
          ...acc,
          [key]: {
            on: Object.entries(subPopulate.on).reduce(
              (acc2, [type, typeSubPopulate]) => ({
                ...acc2,
                [type]: convertNestedPopulate(typeSubPopulate, getModel(type))
              }),
              {}
            )
          }
        };
      }
      if (isDynamicZoneAttribute(attribute)) {
        const populates = attribute.components.map((uid) => getModel(uid)).map((schema2) => convertNestedPopulate(subPopulate, schema2)).map((populate22) => populate22 === true ? {} : populate22).filter((populate22) => populate22 !== false);
        if (fp.isEmpty(populates)) {
          return acc;
        }
        return {
          ...acc,
          [key]: fp.mergeAll(populates)
        };
      }
      if (isMorphToRelationalAttribute(attribute)) {
        return { ...acc, [key]: convertNestedPopulate(subPopulate, void 0) };
      }
      let targetSchemaUID;
      if (attribute.type === "relation") {
        targetSchemaUID = attribute.target;
      } else if (attribute.type === "component") {
        targetSchemaUID = attribute.component;
      } else if (attribute.type === "media") {
        targetSchemaUID = "plugin::upload.file";
      } else {
        return acc;
      }
      const targetSchema = getModel(targetSchemaUID);
      if (!targetSchema) {
        return acc;
      }
      const populateObject = convertNestedPopulate(subPopulate, targetSchema);
      if (!populateObject) {
        return acc;
      }
      return {
        ...acc,
        [key]: populateObject
      };
    }, {});
  };
  const convertNestedPopulate = (subPopulate, schema) => {
    if (___default.default.isString(subPopulate)) {
      return parseType({ type: "boolean", value: subPopulate, forceCast: true });
    }
    if (___default.default.isBoolean(subPopulate)) {
      return subPopulate;
    }
    if (!isPlainObject(subPopulate)) {
      throw new Error(`Invalid nested populate. Expected '*' or an object`);
    }
    const { sort: sort2, filters: filters2, fields: fields2, populate: populate2, count, ordering, page, pageSize, start, limit } = subPopulate;
    const query = {};
    if (sort2) {
      query.orderBy = convertSortQueryParams(sort2);
    }
    if (filters2) {
      query.where = convertFiltersQueryParams(filters2, schema);
    }
    if (fields2) {
      query.select = convertFieldsQueryParams(fields2);
    }
    if (populate2) {
      query.populate = convertPopulateQueryParams(populate2, schema);
    }
    if (count) {
      query.count = convertCountQueryParams(count);
    }
    if (ordering) {
      query.ordering = convertOrderingQueryParams(ordering);
    }
    validatePaginationParams(page, pageSize, start, limit);
    if (!fp.isNil(page)) {
      query.page = convertPageQueryParams(page);
    }
    if (!fp.isNil(pageSize)) {
      query.pageSize = convertPageSizeQueryParams(pageSize, page);
    }
    if (!fp.isNil(start)) {
      query.offset = convertStartQueryParams(start);
    }
    if (!fp.isNil(limit)) {
      query.limit = convertLimitQueryParams(limit);
    }
    return query;
  };
  const convertFieldsQueryParams = (fields2, depth = 0) => {
    if (depth === 0 && fields2 === "*") {
      return void 0;
    }
    if (typeof fields2 === "string") {
      const fieldsValues = fields2.split(",").map((value) => ___default.default.trim(value));
      return ___default.default.uniq([ID_ATTRIBUTE$3, DOC_ID_ATTRIBUTE$3, ...fieldsValues]);
    }
    if (isStringArray$3(fields2)) {
      const fieldsValues = fields2.flatMap((value) => convertFieldsQueryParams(value, depth + 1)).filter((v) => !fp.isNil(v));
      return ___default.default.uniq([ID_ATTRIBUTE$3, DOC_ID_ATTRIBUTE$3, ...fieldsValues]);
    }
    throw new Error("Invalid fields parameter. Expected a string or an array of strings");
  };
  const isValidSchemaAttribute = (key, schema) => {
    if ([DOC_ID_ATTRIBUTE$3, ID_ATTRIBUTE$3].includes(key)) {
      return true;
    }
    if (!schema) {
      return false;
    }
    return Object.keys(schema.attributes).includes(key);
  };
  const convertFiltersQueryParams = (filters2, schema) => {
    if (!fp.isObject(filters2)) {
      throw new Error("The filters parameter must be an object or an array");
    }
    const filtersCopy = fp.cloneDeep(filters2);
    return convertAndSanitizeFilters(filtersCopy, schema);
  };
  const convertAndSanitizeFilters = (filters2, schema) => {
    if (Array.isArray(filters2)) {
      return filters2.map((filter) => convertAndSanitizeFilters(filter, schema)).filter((filter) => !isPlainObject(filter) || !fp.isEmpty(filter));
    }
    if (!isPlainObject(filters2)) {
      return filters2;
    }
    const removeOperator = (operator) => delete filters2[operator];
    for (const [key, value] of Object.entries(filters2)) {
      const attribute = fp.get(key, schema?.attributes);
      const validKey = isOperator(key) || isValidSchemaAttribute(key, schema);
      if (!validKey) {
        removeOperator(key);
      } else if (attribute) {
        if (attribute.type === "relation") {
          filters2[key] = convertAndSanitizeFilters(value, getModel(attribute.target));
        } else if (attribute.type === "component") {
          filters2[key] = convertAndSanitizeFilters(value, getModel(attribute.component));
        } else if (attribute.type === "media") {
          filters2[key] = convertAndSanitizeFilters(value, getModel("plugin::upload.file"));
        } else if (attribute.type === "dynamiczone") {
          removeOperator(key);
        } else if (attribute.type === "password") {
          removeOperator(key);
        } else {
          filters2[key] = convertAndSanitizeFilters(value, schema);
        }
      } else if (["$null", "$notNull"].includes(key)) {
        filters2[key] = parseType({ type: "boolean", value: filters2[key], forceCast: true });
      } else if (fp.isObject(value)) {
        filters2[key] = convertAndSanitizeFilters(value, schema);
      }
      if (isPlainObject(filters2[key]) && fp.isEmpty(filters2[key])) {
        removeOperator(key);
      }
    }
    return filters2;
  };
  const convertStatusParams = (status, query = {}) => {
    query.filters = ({ meta }) => {
      const contentType = getModel(meta.uid);
      if (!contentType || !hasDraftAndPublish(contentType)) {
        return {};
      }
      return { [PUBLISHED_AT_ATTRIBUTE]: { $null: status === "draft" } };
    };
  };
  const transformQueryParams = (uid, params) => {
    const schema = getModel(uid);
    const query = {};
    const { _q, sort: sort2, filters: filters2, fields: fields2, populate: populate2, page, pageSize, start, limit, status, ...rest } = params;
    if (!fp.isNil(status)) {
      convertStatusParams(status, query);
    }
    if (!fp.isNil(_q)) {
      query._q = _q;
    }
    if (!fp.isNil(sort2)) {
      query.orderBy = convertSortQueryParams(sort2);
    }
    if (!fp.isNil(filters2)) {
      query.where = convertFiltersQueryParams(filters2, schema);
    }
    if (!fp.isNil(fields2)) {
      query.select = convertFieldsQueryParams(fields2);
    }
    if (!fp.isNil(populate2)) {
      query.populate = convertPopulateQueryParams(populate2, schema);
    }
    validatePaginationParams(page, pageSize, start, limit);
    if (!fp.isNil(page)) {
      query.page = convertPageQueryParams(page);
    }
    if (!fp.isNil(pageSize)) {
      query.pageSize = convertPageSizeQueryParams(pageSize, page);
    }
    if (!fp.isNil(start)) {
      query.offset = convertStartQueryParams(start);
    }
    if (!fp.isNil(limit)) {
      query.limit = convertLimitQueryParams(limit);
    }
    return {
      ...rest,
      ...query
    };
  };
  return {
    private_convertSortQueryParams: convertSortQueryParams,
    private_convertStartQueryParams: convertStartQueryParams,
    private_convertLimitQueryParams: convertLimitQueryParams,
    private_convertPopulateQueryParams: convertPopulateQueryParams,
    private_convertFiltersQueryParams: convertFiltersQueryParams,
    private_convertFieldsQueryParams: convertFieldsQueryParams,
    transformQueryParams
  };
};
const convertQueryParams = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createTransformer
}, Symbol.toStringTag, { value: "Module" }));
function pipe(...fns) {
  const [firstFn, ...fnRest] = fns;
  return async (...args) => {
    let res = await firstFn.apply(firstFn, args);
    for (let i = 0; i < fnRest.length; i += 1) {
      res = await fnRest[i](res);
    }
    return res;
  };
}
const map = fp.curry(pMap__default.default);
const reduce = (mixedArray) => async (iteratee, initialValue) => {
  let acc = initialValue;
  for (let i = 0; i < mixedArray.length; i += 1) {
    acc = await iteratee(acc, await mixedArray[i], i);
  }
  return acc;
};
const async = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  map,
  pipe,
  reduce
}, Symbol.toStringTag, { value: "Module" }));
const visitor$8 = ({ key, attribute }, { remove }) => {
  if (attribute?.type === "password") {
    remove(key);
  }
};
const visitor$7 = ({ schema, key, attribute }, { remove }) => {
  if (!attribute) {
    return;
  }
  const isPrivate = attribute.private === true || isPrivateAttribute(schema, key);
  if (isPrivate) {
    remove(key);
  }
};
const ACTIONS_TO_VERIFY$1 = ["find"];
const { CREATED_BY_ATTRIBUTE: CREATED_BY_ATTRIBUTE$1, UPDATED_BY_ATTRIBUTE: UPDATED_BY_ATTRIBUTE$1 } = constants$1;
const removeRestrictedRelations = (auth) => async ({ data, key, attribute, schema }, { remove, set }) => {
  if (!attribute) {
    return;
  }
  const isRelation = attribute.type === "relation";
  if (!isRelation) {
    return;
  }
  const handleMorphRelation = async () => {
    const newMorphValue = [];
    for (const element of data[key]) {
      const scopes = ACTIONS_TO_VERIFY$1.map((action) => `${element.__type}.${action}`);
      const isAllowed = await hasAccessToSomeScopes$1(scopes, auth);
      if (isAllowed) {
        newMorphValue.push(element);
      }
    }
    if (newMorphValue.length === 0) {
      remove(key);
    } else {
      set(key, newMorphValue);
    }
  };
  const handleRegularRelation = async () => {
    const scopes = ACTIONS_TO_VERIFY$1.map((action) => `${attribute.target}.${action}`);
    const isAllowed = await hasAccessToSomeScopes$1(scopes, auth);
    if (!isAllowed) {
      remove(key);
    }
  };
  const isCreatorRelation = [CREATED_BY_ATTRIBUTE$1, UPDATED_BY_ATTRIBUTE$1].includes(key);
  if (isMorphToRelationalAttribute(attribute)) {
    await handleMorphRelation();
    return;
  }
  if (isCreatorRelation && schema.options?.populateCreatorFields) {
    return;
  }
  await handleRegularRelation();
};
const hasAccessToSomeScopes$1 = async (scopes, auth) => {
  for (const scope of scopes) {
    try {
      await strapi.auth.verify(auth, { scope });
      return true;
    } catch {
      continue;
    }
  }
  return false;
};
const visitor$6 = ({ key, attribute }, { remove }) => {
  if (isMorphToRelationalAttribute(attribute)) {
    remove(key);
  }
};
const visitor$5 = ({ key, attribute }, { remove }) => {
  if (isDynamicZoneAttribute(attribute)) {
    remove(key);
  }
};
const removeDisallowedFields = (allowedFields = null) => ({ key, path: { attribute: path } }, { remove }) => {
  if (allowedFields === null) {
    return;
  }
  if (!(fp.isArray(allowedFields) && allowedFields.every(fp.isString))) {
    throw new TypeError(
      `Expected array of strings for allowedFields but got "${typeof allowedFields}"`
    );
  }
  if (fp.isNil(path)) {
    return;
  }
  const containedPaths = getContainedPaths$1(path);
  const isPathAllowed = allowedFields.some(
    (p) => containedPaths.includes(p) || p.startsWith(`${path}.`)
  );
  if (isPathAllowed) {
    return;
  }
  remove(key);
};
const getContainedPaths$1 = (path) => {
  const parts = fp.toPath(path);
  return parts.reduce((acc, value, index2, list) => {
    return [...acc, list.slice(0, index2 + 1).join(".")];
  }, []);
};
const removeRestrictedFields = (restrictedFields = null) => ({ key, path: { attribute: path } }, { remove }) => {
  if (restrictedFields === null) {
    remove(key);
    return;
  }
  if (!(fp.isArray(restrictedFields) && restrictedFields.every(fp.isString))) {
    throw new TypeError(
      `Expected array of strings for restrictedFields but got "${typeof restrictedFields}"`
    );
  }
  if (restrictedFields.includes(path)) {
    remove(key);
    return;
  }
  const isRestrictedNested = restrictedFields.some(
    (allowedPath) => path?.toString().startsWith(`${allowedPath}.`)
  );
  if (isRestrictedNested) {
    remove(key);
  }
};
const visitor$4 = ({ schema, key, value }, { set }) => {
  if (key === "" && value === "*") {
    const { attributes } = schema;
    const newPopulateQuery = Object.entries(attributes).filter(
      ([, attribute]) => ["relation", "component", "media", "dynamiczone"].includes(attribute.type)
    ).reduce((acc, [key2]) => ({ ...acc, [key2]: true }), {});
    set("", newPopulateQuery);
  }
};
const index$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  expandWildcardPopulate: visitor$4,
  removeDisallowedFields,
  removeDynamicZones: visitor$5,
  removeMorphToRelations: visitor$6,
  removePassword: visitor$8,
  removePrivate: visitor$7,
  removeRestrictedFields,
  removeRestrictedRelations
}, Symbol.toStringTag, { value: "Module" }));
const DEFAULT_PATH = { raw: null, attribute: null };
const traverseFactory = () => {
  const state = {
    parsers: [],
    interceptors: [],
    ignore: [],
    handlers: {
      attributes: [],
      common: []
    }
  };
  const traverse = async (visitor2, options, data) => {
    const { path = DEFAULT_PATH, schema, getModel } = options ?? {};
    for (const { predicate, handler } of state.interceptors) {
      if (predicate(data)) {
        return handler(visitor2, options, data, { recurse: traverse });
      }
    }
    const parser = state.parsers.find((parser2) => parser2.predicate(data))?.parser;
    const utils2 = parser?.(data);
    if (!utils2) {
      return data;
    }
    let out = utils2.transform(data);
    const keys = utils2.keys(out);
    for (const key of keys) {
      const attribute = schema?.attributes?.[key];
      const newPath = { ...path };
      newPath.raw = fp.isNil(path.raw) ? key : `${path.raw}.${key}`;
      if (!fp.isNil(attribute)) {
        newPath.attribute = fp.isNil(path.attribute) ? key : `${path.attribute}.${key}`;
      }
      const visitorOptions = {
        key,
        value: utils2.get(key, out),
        attribute,
        schema,
        path: newPath,
        data: out,
        getModel
      };
      const transformUtils = {
        remove(key2) {
          out = utils2.remove(key2, out);
        },
        set(key2, value2) {
          out = utils2.set(key2, value2, out);
        },
        recurse: traverse
      };
      await visitor2(visitorOptions, fp.pick(["remove", "set"], transformUtils));
      const value = utils2.get(key, out);
      const createContext = () => ({
        key,
        value,
        attribute,
        schema,
        path: newPath,
        data: out,
        visitor: visitor2,
        getModel
      });
      const ignoreCtx = createContext();
      const shouldIgnore = state.ignore.some((predicate) => predicate(ignoreCtx));
      if (shouldIgnore) {
        continue;
      }
      const handlers = [...state.handlers.common, ...state.handlers.attributes];
      for await (const handler of handlers) {
        const ctx = createContext();
        const pass = await handler.predicate(ctx);
        if (pass) {
          await handler.handler(ctx, fp.pick(["recurse", "set"], transformUtils));
        }
      }
    }
    return out;
  };
  return {
    traverse,
    intercept(predicate, handler) {
      state.interceptors.push({ predicate, handler });
      return this;
    },
    parse(predicate, parser) {
      state.parsers.push({ predicate, parser });
      return this;
    },
    ignore(predicate) {
      state.ignore.push(predicate);
      return this;
    },
    on(predicate, handler) {
      state.handlers.common.push({ predicate, handler });
      return this;
    },
    onAttribute(predicate, handler) {
      state.handlers.attributes.push({ predicate, handler });
      return this;
    },
    onRelation(handler) {
      return this.onAttribute(({ attribute }) => attribute?.type === "relation", handler);
    },
    onMedia(handler) {
      return this.onAttribute(({ attribute }) => attribute?.type === "media", handler);
    },
    onComponent(handler) {
      return this.onAttribute(({ attribute }) => attribute?.type === "component", handler);
    },
    onDynamicZone(handler) {
      return this.onAttribute(({ attribute }) => attribute?.type === "dynamiczone", handler);
    }
  };
};
const isObj$2 = (value) => fp.isObject(value);
const filters = traverseFactory().intercept(
  // Intercept filters arrays and apply the traversal to each one individually
  fp.isArray,
  async (visitor2, options, filters2, { recurse }) => {
    return Promise.all(
      filters2.map((filter, i) => {
        const newPath = options.path ? { ...options.path, raw: `${options.path.raw}[${i}]` } : options.path;
        return recurse(visitor2, { ...options, path: newPath }, filter);
      })
      // todo: move that to the visitors
    ).then((res) => res.filter((val) => !(fp.isObject(val) && fp.isEmpty(val))));
  }
).intercept(
  // Ignore non object filters and return the value as-is
  (filters2) => !fp.isObject(filters2),
  (_2, __, filters2) => {
    return filters2;
  }
).parse(isObj$2, () => ({
  transform: fp.cloneDeep,
  remove(key, data) {
    return fp.omit(key, data);
  },
  set(key, value, data) {
    return { ...data, [key]: value };
  },
  keys(data) {
    return Object.keys(data);
  },
  get(key, data) {
    return data[key];
  }
})).ignore(({ value }) => fp.isNil(value)).on(
  ({ attribute }) => fp.isNil(attribute),
  async ({ key, visitor: visitor2, path, value, schema, getModel }, { set, recurse }) => {
    set(key, await recurse(visitor2, { schema, path, getModel }, value));
  }
).onRelation(async ({ key, attribute, visitor: visitor2, path, value, getModel }, { set, recurse }) => {
  const isMorphRelation = attribute.relation.toLowerCase().startsWith("morph");
  if (isMorphRelation) {
    return;
  }
  const targetSchemaUID = attribute.target;
  const targetSchema = getModel(targetSchemaUID);
  const newValue = await recurse(visitor2, { schema: targetSchema, path, getModel }, value);
  set(key, newValue);
}).onComponent(async ({ key, attribute, visitor: visitor2, path, value, getModel }, { set, recurse }) => {
  const targetSchema = getModel(attribute.component);
  const newValue = await recurse(visitor2, { schema: targetSchema, path, getModel }, value);
  set(key, newValue);
}).onMedia(async ({ key, visitor: visitor2, path, value, getModel }, { set, recurse }) => {
  const targetSchemaUID = "plugin::upload.file";
  const targetSchema = getModel(targetSchemaUID);
  const newValue = await recurse(visitor2, { schema: targetSchema, path, getModel }, value);
  set(key, newValue);
});
const traverseQueryFilters = fp.curry(filters.traverse);
const ORDERS = { asc: "asc", desc: "desc" };
const ORDER_VALUES = Object.values(ORDERS);
const isSortOrder = (value) => ORDER_VALUES.includes(value.toLowerCase());
const isStringArray$2 = (value) => Array.isArray(value) && value.every(fp.isString);
const isObjectArray = (value) => Array.isArray(value) && value.every(fp.isObject);
const isNestedSorts = (value) => fp.isString(value) && value.split(",").length > 1;
const isObj$1 = (value) => fp.isObject(value);
const sort = traverseFactory().intercept(
  // String with chained sorts (foo,bar,foobar) => split, map(recurse), then recompose
  isNestedSorts,
  async (visitor2, options, sort2, { recurse }) => {
    return Promise.all(
      sort2.split(",").map(fp.trim).map((nestedSort) => recurse(visitor2, options, nestedSort))
    ).then((res) => res.filter((part) => !fp.isEmpty(part)).join(","));
  }
).intercept(
  // Array of strings ['foo', 'foo,bar'] => map(recurse), then filter out empty items
  isStringArray$2,
  async (visitor2, options, sort2, { recurse }) => {
    return Promise.all(sort2.map((nestedSort) => recurse(visitor2, options, nestedSort))).then(
      (res) => res.filter((nestedSort) => !fp.isEmpty(nestedSort))
    );
  }
).intercept(
  // Array of objects [{ foo: 'asc' }, { bar: 'desc', baz: 'asc' }] => map(recurse), then filter out empty items
  isObjectArray,
  async (visitor2, options, sort2, { recurse }) => {
    return Promise.all(sort2.map((nestedSort) => recurse(visitor2, options, nestedSort))).then(
      (res) => res.filter((nestedSort) => !fp.isEmpty(nestedSort))
    );
  }
).parse(fp.isString, () => {
  const tokenize = fp.pipe(fp.split("."), fp.map(fp.split(":")), fp.flatten);
  const recompose = (parts) => {
    if (parts.length === 0) {
      return void 0;
    }
    return parts.reduce((acc, part) => {
      if (fp.isEmpty(part)) {
        return acc;
      }
      if (acc === "") {
        return part;
      }
      return isSortOrder(part) ? `${acc}:${part}` : `${acc}.${part}`;
    }, "");
  };
  return {
    transform: fp.trim,
    remove(key, data) {
      const [root] = tokenize(data);
      return root === key ? void 0 : data;
    },
    set(key, value, data) {
      const [root] = tokenize(data);
      if (root !== key) {
        return data;
      }
      return fp.isNil(value) ? root : `${root}.${value}`;
    },
    keys(data) {
      const v = fp.first(tokenize(data));
      return v ? [v] : [];
    },
    get(key, data) {
      const [root, ...rest] = tokenize(data);
      return key === root ? recompose(rest) : void 0;
    }
  };
}).parse(isObj$1, () => ({
  transform: fp.cloneDeep,
  remove(key, data) {
    const { [key]: ignored, ...rest } = data;
    return rest;
  },
  set(key, value, data) {
    return { ...data, [key]: value };
  },
  keys(data) {
    return Object.keys(data);
  },
  get(key, data) {
    return data[key];
  }
})).onRelation(async ({ key, value, attribute, visitor: visitor2, path, getModel }, { set, recurse }) => {
  const isMorphRelation = attribute.relation.toLowerCase().startsWith("morph");
  if (isMorphRelation) {
    return;
  }
  const targetSchemaUID = attribute.target;
  const targetSchema = getModel(targetSchemaUID);
  const newValue = await recurse(visitor2, { schema: targetSchema, path, getModel }, value);
  set(key, newValue);
}).onMedia(async ({ key, path, visitor: visitor2, value, getModel }, { recurse, set }) => {
  const targetSchemaUID = "plugin::upload.file";
  const targetSchema = getModel(targetSchemaUID);
  const newValue = await recurse(visitor2, { schema: targetSchema, path, getModel }, value);
  set(key, newValue);
}).onComponent(async ({ key, value, visitor: visitor2, path, attribute, getModel }, { recurse, set }) => {
  const targetSchema = getModel(attribute.component);
  const newValue = await recurse(visitor2, { schema: targetSchema, path, getModel }, value);
  set(key, newValue);
});
const traverseQuerySort = fp.curry(sort.traverse);
const isKeyword = (keyword) => {
  return ({ key, attribute }) => {
    return !attribute && keyword === key;
  };
};
const isStringArray$1 = (value) => fp.isArray(value) && value.every(fp.isString);
const isObj = (value) => fp.isObject(value);
const populate = traverseFactory().intercept(isStringArray$1, async (visitor2, options, populate2, { recurse }) => {
  const visitedPopulate = await Promise.all(
    populate2.map((nestedPopulate) => recurse(visitor2, options, nestedPopulate))
  );
  return visitedPopulate.filter((item) => !fp.isNil(item));
}).parse(
  (value) => value === "*",
  () => ({
    /**
     * Since value is '*', we don't need to transform it
     */
    transform: fp.identity,
    /**
     * '*' isn't a key/value structure, so regardless
     *  of the given key, it returns the data ('*')
     */
    get: (_key, data) => data,
    /**
     * '*' isn't a key/value structure, so regardless
     * of the given `key`, use `value` as the new `data`
     */
    set: (_key, value) => value,
    /**
     * '*' isn't a key/value structure, but we need to simulate at least one to enable
     * the data traversal. We're using '' since it represents a falsy string value
     */
    keys: fp.constant([""]),
    /**
     * Removing '*' means setting it to undefined, regardless of the given key
     */
    remove: fp.constant(void 0)
  })
).parse(fp.isString, () => {
  const tokenize = fp.split(".");
  const recompose = fp.join(".");
  return {
    transform: fp.trim,
    remove(key, data) {
      const [root] = tokenize(data);
      return root === key ? void 0 : data;
    },
    set(key, value, data) {
      const [root] = tokenize(data);
      if (root !== key) {
        return data;
      }
      return fp.isNil(value) || fp.isEmpty(value) ? root : `${root}.${value}`;
    },
    keys(data) {
      const v = fp.first(tokenize(data));
      return v ? [v] : [];
    },
    get(key, data) {
      const [root, ...rest] = tokenize(data);
      return key === root ? recompose(rest) : void 0;
    }
  };
}).parse(isObj, () => ({
  transform: fp.cloneDeep,
  remove(key, data) {
    const { [key]: ignored, ...rest } = data;
    return rest;
  },
  set(key, value, data) {
    return { ...data, [key]: value };
  },
  keys(data) {
    return Object.keys(data);
  },
  get(key, data) {
    return data[key];
  }
})).ignore(({ key, attribute }) => {
  return ["sort", "filters", "fields"].includes(key) && !attribute;
}).on(
  // Handle recursion on populate."populate"
  isKeyword("populate"),
  async ({ key, visitor: visitor2, path, value, schema, getModel }, { set, recurse }) => {
    const newValue = await recurse(visitor2, { schema, path, getModel }, value);
    set(key, newValue);
  }
).on(isKeyword("on"), async ({ key, visitor: visitor2, path, value, getModel }, { set, recurse }) => {
  const newOn = {};
  if (!isObj(value)) {
    return;
  }
  for (const [uid, subPopulate] of Object.entries(value)) {
    const model = getModel(uid);
    const newPath = { ...path, raw: `${path.raw}[${uid}]` };
    newOn[uid] = await recurse(visitor2, { schema: model, path: newPath, getModel }, subPopulate);
  }
  set(key, newOn);
}).onRelation(
  async ({ key, value, attribute, visitor: visitor2, path, schema, getModel }, { set, recurse }) => {
    if (fp.isNil(value)) {
      return;
    }
    if (isMorphToRelationalAttribute(attribute)) {
      if (!fp.isObject(value) || !("on" in value && fp.isObject(value?.on))) {
        return;
      }
      const newValue2 = await recurse(visitor2, { schema, path, getModel }, { on: value?.on });
      set(key, { on: newValue2 });
    }
    const targetSchemaUID = attribute.target;
    const targetSchema = getModel(targetSchemaUID);
    const newValue = await recurse(visitor2, { schema: targetSchema, path, getModel }, value);
    set(key, newValue);
  }
).onMedia(async ({ key, path, visitor: visitor2, value, getModel }, { recurse, set }) => {
  if (fp.isNil(value)) {
    return;
  }
  const targetSchemaUID = "plugin::upload.file";
  const targetSchema = getModel(targetSchemaUID);
  const newValue = await recurse(visitor2, { schema: targetSchema, path, getModel }, value);
  set(key, newValue);
}).onComponent(async ({ key, value, visitor: visitor2, path, attribute, getModel }, { recurse, set }) => {
  if (fp.isNil(value)) {
    return;
  }
  const targetSchema = getModel(attribute.component);
  const newValue = await recurse(visitor2, { schema: targetSchema, path, getModel }, value);
  set(key, newValue);
}).onDynamicZone(
  async ({ key, value, attribute, schema, visitor: visitor2, path, getModel }, { set, recurse }) => {
    if (fp.isNil(value)) {
      return;
    }
    if (fp.isObject(value)) {
      const { components } = attribute;
      const newValue = {};
      let newProperties = fp.omit("on", value);
      for (const componentUID of components) {
        const componentSchema = getModel(componentUID);
        const properties = await recurse(
          visitor2,
          { schema: componentSchema, path, getModel },
          value
        );
        newProperties = fp.merge(newProperties, properties);
      }
      Object.assign(newValue, newProperties);
      if ("on" in value && value.on) {
        const newOn = await recurse(visitor2, { schema, path, getModel }, { on: value.on });
        Object.assign(newValue, newOn);
      }
      set(key, newValue);
    } else {
      const newValue = await recurse(visitor2, { schema, path, getModel }, value);
      set(key, newValue);
    }
  }
);
const traverseQueryPopulate = fp.curry(populate.traverse);
const isStringArray = (value) => fp.isArray(value) && value.every(fp.isString);
const fields = traverseFactory().intercept(isStringArray, async (visitor2, options, fields2, { recurse }) => {
  return Promise.all(fields2.map((field) => recurse(visitor2, options, field)));
}).intercept((value) => fp.eq("*", value), fp.constant("*")).parse(fp.isString, () => ({
  transform: fp.trim,
  remove(key, data) {
    return data === key ? void 0 : data;
  },
  set(_key, _value, data) {
    return data;
  },
  keys(data) {
    return [data];
  },
  get(key, data) {
    return key === data ? data : void 0;
  }
}));
const traverseQueryFields = fp.curry(fields.traverse);
const index$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  traverseQueryFields,
  traverseQueryFilters,
  traverseQueryPopulate,
  traverseQuerySort
}, Symbol.toStringTag, { value: "Module" }));
const { ID_ATTRIBUTE: ID_ATTRIBUTE$2, DOC_ID_ATTRIBUTE: DOC_ID_ATTRIBUTE$2 } = constants$1;
const sanitizePasswords = (ctx) => async (entity) => {
  if (!ctx.schema) {
    throw new Error("Missing schema in sanitizePasswords");
  }
  return traverseEntity$1(visitor$8, ctx, entity);
};
const defaultSanitizeOutput = async (ctx, entity) => {
  if (!ctx.schema) {
    throw new Error("Missing schema in defaultSanitizeOutput");
  }
  return traverseEntity$1(
    (...args) => {
      visitor$8(...args);
      visitor$7(...args);
    },
    ctx,
    entity
  );
};
const defaultSanitizeFilters = fp.curry((ctx, filters2) => {
  if (!ctx.schema) {
    throw new Error("Missing schema in defaultSanitizeFilters");
  }
  return pipe(
    // Remove keys that are not attributes or valid operators
    traverseQueryFilters(({ key, attribute }, { remove }) => {
      const isAttribute = !!attribute;
      if ([ID_ATTRIBUTE$2, DOC_ID_ATTRIBUTE$2].includes(key)) {
        return;
      }
      if (!isAttribute && !isOperator(key)) {
        remove(key);
      }
    }, ctx),
    // Remove dynamic zones from filters
    traverseQueryFilters(visitor$5, ctx),
    // Remove morpTo relations from filters
    traverseQueryFilters(visitor$6, ctx),
    // Remove passwords from filters
    traverseQueryFilters(visitor$8, ctx),
    // Remove private from filters
    traverseQueryFilters(visitor$7, ctx),
    // Remove empty objects
    traverseQueryFilters(({ key, value }, { remove }) => {
      if (fp.isObject(value) && fp.isEmpty(value)) {
        remove(key);
      }
    }, ctx)
  )(filters2);
});
const defaultSanitizeSort = fp.curry((ctx, sort2) => {
  if (!ctx.schema) {
    throw new Error("Missing schema in defaultSanitizeSort");
  }
  return pipe(
    // Remove non attribute keys
    traverseQuerySort(({ key, attribute }, { remove }) => {
      if ([ID_ATTRIBUTE$2, DOC_ID_ATTRIBUTE$2].includes(key)) {
        return;
      }
      if (!attribute) {
        remove(key);
      }
    }, ctx),
    // Remove dynamic zones from sort
    traverseQuerySort(visitor$5, ctx),
    // Remove morpTo relations from sort
    traverseQuerySort(visitor$6, ctx),
    // Remove private from sort
    traverseQuerySort(visitor$7, ctx),
    // Remove passwords from filters
    traverseQuerySort(visitor$8, ctx),
    // Remove keys for empty non-scalar values
    traverseQuerySort(({ key, attribute, value }, { remove }) => {
      if ([ID_ATTRIBUTE$2, DOC_ID_ATTRIBUTE$2].includes(key)) {
        return;
      }
      if (!isScalarAttribute(attribute) && fp.isEmpty(value)) {
        remove(key);
      }
    }, ctx)
  )(sort2);
});
const defaultSanitizeFields = fp.curry((ctx, fields2) => {
  if (!ctx.schema) {
    throw new Error("Missing schema in defaultSanitizeFields");
  }
  return pipe(
    // Only keep scalar attributes
    traverseQueryFields(({ key, attribute }, { remove }) => {
      if ([ID_ATTRIBUTE$2, DOC_ID_ATTRIBUTE$2].includes(key)) {
        return;
      }
      if (fp.isNil(attribute) || !isScalarAttribute(attribute)) {
        remove(key);
      }
    }, ctx),
    // Remove private fields
    traverseQueryFields(visitor$7, ctx),
    // Remove password fields
    traverseQueryFields(visitor$8, ctx),
    // Remove nil values from fields array
    (value) => fp.isArray(value) ? value.filter((field) => !fp.isNil(field)) : value
  )(fields2);
});
const defaultSanitizePopulate = fp.curry((ctx, populate2) => {
  if (!ctx.schema) {
    throw new Error("Missing schema in defaultSanitizePopulate");
  }
  return pipe(
    traverseQueryPopulate(visitor$4, ctx),
    traverseQueryPopulate(async ({ key, value, schema, attribute, getModel }, { set }) => {
      if (attribute) {
        return;
      }
      if (key === "sort") {
        set(key, await defaultSanitizeSort({ schema, getModel }, value));
      }
      if (key === "filters") {
        set(key, await defaultSanitizeFilters({ schema, getModel }, value));
      }
      if (key === "fields") {
        set(key, await defaultSanitizeFields({ schema, getModel }, value));
      }
      if (key === "populate") {
        set(key, await defaultSanitizePopulate({ schema, getModel }, value));
      }
    }, ctx),
    // Remove private fields
    traverseQueryPopulate(visitor$7, ctx)
  )(populate2);
});
const sanitizers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultSanitizeFields,
  defaultSanitizeFilters,
  defaultSanitizeOutput,
  defaultSanitizePopulate,
  defaultSanitizeSort,
  sanitizePasswords
}, Symbol.toStringTag, { value: "Module" }));
const createAPISanitizers = (opts) => {
  const { getModel } = opts;
  const sanitizeInput = (data, schema, { auth } = {}) => {
    if (!schema) {
      throw new Error("Missing schema in sanitizeInput");
    }
    if (fp.isArray(data)) {
      return Promise.all(data.map((entry) => sanitizeInput(entry, schema, { auth })));
    }
    const nonWritableAttributes = getNonWritableAttributes(schema);
    const transforms = [
      // Remove first level ID in inputs
      fp.omit(constants$1.ID_ATTRIBUTE),
      fp.omit(constants$1.DOC_ID_ATTRIBUTE),
      // Remove non-writable attributes
      traverseEntity$1(removeRestrictedFields(nonWritableAttributes), { schema, getModel })
    ];
    if (auth) {
      transforms.push(
        traverseEntity$1(removeRestrictedRelations(auth), { schema, getModel })
      );
    }
    opts?.sanitizers?.input?.forEach((sanitizer) => transforms.push(sanitizer(schema)));
    return pipe(...transforms)(data);
  };
  const sanitizeOutput = async (data, schema, { auth } = {}) => {
    if (!schema) {
      throw new Error("Missing schema in sanitizeOutput");
    }
    if (fp.isArray(data)) {
      const res = new Array(data.length);
      for (let i = 0; i < data.length; i += 1) {
        res[i] = await sanitizeOutput(data[i], schema, { auth });
      }
      return res;
    }
    const transforms = [
      (data2) => defaultSanitizeOutput({ schema, getModel }, data2)
    ];
    if (auth) {
      transforms.push(
        traverseEntity$1(removeRestrictedRelations(auth), { schema, getModel })
      );
    }
    opts?.sanitizers?.output?.forEach((sanitizer) => transforms.push(sanitizer(schema)));
    return pipe(...transforms)(data);
  };
  const sanitizeQuery = async (query, schema, { auth } = {}) => {
    if (!schema) {
      throw new Error("Missing schema in sanitizeQuery");
    }
    const { filters: filters2, sort: sort2, fields: fields2, populate: populate2 } = query;
    const sanitizedQuery = fp.cloneDeep(query);
    if (filters2) {
      Object.assign(sanitizedQuery, { filters: await sanitizeFilters(filters2, schema, { auth }) });
    }
    if (sort2) {
      Object.assign(sanitizedQuery, { sort: await sanitizeSort(sort2, schema, { auth }) });
    }
    if (fields2) {
      Object.assign(sanitizedQuery, { fields: await sanitizeFields(fields2, schema) });
    }
    if (populate2) {
      Object.assign(sanitizedQuery, { populate: await sanitizePopulate(populate2, schema) });
    }
    return sanitizedQuery;
  };
  const sanitizeFilters = (filters2, schema, { auth } = {}) => {
    if (!schema) {
      throw new Error("Missing schema in sanitizeFilters");
    }
    if (fp.isArray(filters2)) {
      return Promise.all(filters2.map((filter) => sanitizeFilters(filter, schema, { auth })));
    }
    const transforms = [defaultSanitizeFilters({ schema, getModel })];
    if (auth) {
      transforms.push(
        traverseQueryFilters(removeRestrictedRelations(auth), { schema, getModel })
      );
    }
    return pipe(...transforms)(filters2);
  };
  const sanitizeSort = (sort2, schema, { auth } = {}) => {
    if (!schema) {
      throw new Error("Missing schema in sanitizeSort");
    }
    const transforms = [defaultSanitizeSort({ schema, getModel })];
    if (auth) {
      transforms.push(
        traverseQuerySort(removeRestrictedRelations(auth), { schema, getModel })
      );
    }
    return pipe(...transforms)(sort2);
  };
  const sanitizeFields = (fields2, schema) => {
    if (!schema) {
      throw new Error("Missing schema in sanitizeFields");
    }
    const transforms = [defaultSanitizeFields({ schema, getModel })];
    return pipe(...transforms)(fields2);
  };
  const sanitizePopulate = (populate2, schema, { auth } = {}) => {
    if (!schema) {
      throw new Error("Missing schema in sanitizePopulate");
    }
    const transforms = [defaultSanitizePopulate({ schema, getModel })];
    if (auth) {
      transforms.push(
        traverseQueryPopulate(removeRestrictedRelations(auth), { schema, getModel })
      );
    }
    return pipe(...transforms)(populate2);
  };
  return {
    input: sanitizeInput,
    output: sanitizeOutput,
    query: sanitizeQuery,
    filters: sanitizeFilters,
    sort: sanitizeSort,
    fields: sanitizeFields,
    populate: sanitizePopulate
  };
};
const index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createAPISanitizers,
  sanitizers,
  visitors: index$4
}, Symbol.toStringTag, { value: "Module" }));
const throwInvalidParam = ({ key, path }) => {
  const msg = path && path !== key ? `Invalid parameter ${key} at ${path}` : `Invalid parameter ${key}`;
  throw new ValidationError(msg);
};
const visitor$3 = ({ key, attribute, path }) => {
  if (attribute?.type === "password") {
    throwInvalidParam({ key, path: path.attribute });
  }
};
const visitor$2 = ({ schema, key, attribute, path }) => {
  if (!attribute) {
    return;
  }
  const isPrivate = attribute.private === true || isPrivateAttribute(schema, key);
  if (isPrivate) {
    throwInvalidParam({ key, path: path.attribute });
  }
};
const ACTIONS_TO_VERIFY = ["find"];
const { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = constants$1;
const throwRestrictedRelations = (auth) => async ({ data, key, attribute, schema, path }) => {
  if (!attribute) {
    return;
  }
  const isRelation = attribute.type === "relation";
  if (!isRelation) {
    return;
  }
  const handleMorphRelation = async () => {
    for (const element of data[key]) {
      const scopes = ACTIONS_TO_VERIFY.map((action) => `${element.__type}.${action}`);
      const isAllowed = await hasAccessToSomeScopes(scopes, auth);
      if (!isAllowed) {
        throwInvalidParam({ key, path: path.attribute });
      }
    }
  };
  const handleRegularRelation = async () => {
    const scopes = ACTIONS_TO_VERIFY.map((action) => `${attribute.target}.${action}`);
    const isAllowed = await hasAccessToSomeScopes(scopes, auth);
    if (!isAllowed) {
      throwInvalidParam({ key, path: path.attribute });
    }
  };
  const isCreatorRelation = [CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE].includes(key);
  if (isMorphToRelationalAttribute(attribute)) {
    await handleMorphRelation();
    return;
  }
  if (isCreatorRelation && schema.options?.populateCreatorFields) {
    return;
  }
  await handleRegularRelation();
};
const hasAccessToSomeScopes = async (scopes, auth) => {
  for (const scope of scopes) {
    try {
      await strapi.auth.verify(auth, { scope });
      return true;
    } catch {
      continue;
    }
  }
  return false;
};
const visitor$1 = ({ key, attribute, path }) => {
  if (isMorphToRelationalAttribute(attribute)) {
    throwInvalidParam({ key, path: path.attribute });
  }
};
const visitor = ({ key, attribute, path }) => {
  if (isDynamicZoneAttribute(attribute)) {
    throwInvalidParam({ key, path: path.attribute });
  }
};
const throwDisallowedFields = (allowedFields = null) => ({ key, path: { attribute: path } }) => {
  if (allowedFields === null) {
    return;
  }
  if (!(fp.isArray(allowedFields) && allowedFields.every(fp.isString))) {
    throw new TypeError(
      `Expected array of strings for allowedFields but got "${typeof allowedFields}"`
    );
  }
  if (fp.isNil(path)) {
    return;
  }
  const containedPaths = getContainedPaths(path);
  const isPathAllowed = allowedFields.some(
    (p) => containedPaths.includes(p) || p.startsWith(`${path}.`)
  );
  if (isPathAllowed) {
    return;
  }
  throwInvalidParam({ key, path });
};
const getContainedPaths = (path) => {
  const parts = fp.toPath(path);
  return parts.reduce((acc, value, index2, list) => {
    return [...acc, list.slice(0, index2 + 1).join(".")];
  }, []);
};
const throwRestrictedFields = (restrictedFields = null) => ({ key, path: { attribute: path } }) => {
  if (restrictedFields === null) {
    throwInvalidParam({ key, path });
  }
  if (!(fp.isArray(restrictedFields) && restrictedFields.every(fp.isString))) {
    throw new TypeError(
      `Expected array of strings for restrictedFields but got "${typeof restrictedFields}"`
    );
  }
  if (restrictedFields.includes(path)) {
    throwInvalidParam({ key, path });
  }
  const isRestrictedNested = restrictedFields.some(
    (allowedPath) => path?.toString().startsWith(`${allowedPath}.`)
  );
  if (isRestrictedNested) {
    throwInvalidParam({ key, path });
  }
};
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  throwDisallowedFields,
  throwDynamicZones: visitor,
  throwMorphToRelations: visitor$1,
  throwPassword: visitor$3,
  throwPrivate: visitor$2,
  throwRestrictedFields,
  throwRestrictedRelations
}, Symbol.toStringTag, { value: "Module" }));
const { ID_ATTRIBUTE: ID_ATTRIBUTE$1, DOC_ID_ATTRIBUTE: DOC_ID_ATTRIBUTE$1 } = constants$1;
const throwPasswords = (ctx) => async (entity) => {
  if (!ctx.schema) {
    throw new Error("Missing schema in throwPasswords");
  }
  return traverseEntity$1(visitor$3, ctx, entity);
};
const defaultValidateFilters = fp.curry((ctx, filters2) => {
  if (!ctx.schema) {
    throw new Error("Missing schema in defaultValidateFilters");
  }
  return pipe(
    // keys that are not attributes or valid operators
    traverseQueryFilters(({ key, attribute, path }) => {
      if ([ID_ATTRIBUTE$1, DOC_ID_ATTRIBUTE$1].includes(key)) {
        return;
      }
      const isAttribute = !!attribute;
      if (!isAttribute && !isOperator(key)) {
        throwInvalidParam({ key, path: path.attribute });
      }
    }, ctx),
    // dynamic zones from filters
    traverseQueryFilters(visitor, ctx),
    // morphTo relations from filters; because you can't have deep filtering on morph relations
    traverseQueryFilters(visitor$1, ctx),
    // passwords from filters
    traverseQueryFilters(visitor$3, ctx),
    // private from filters
    traverseQueryFilters(visitor$2, ctx)
    // we allow empty objects to validate and only sanitize them out, so that users may write "lazy" queries without checking their params exist
  )(filters2);
});
const defaultValidateSort = fp.curry((ctx, sort2) => {
  if (!ctx.schema) {
    throw new Error("Missing schema in defaultValidateSort");
  }
  return pipe(
    // non attribute keys
    traverseQuerySort(({ key, attribute, path }) => {
      if ([ID_ATTRIBUTE$1, DOC_ID_ATTRIBUTE$1].includes(key)) {
        return;
      }
      if (!attribute) {
        throwInvalidParam({ key, path: path.attribute });
      }
    }, ctx),
    // dynamic zones from sort
    traverseQuerySort(visitor, ctx),
    // morphTo relations from sort
    traverseQuerySort(visitor$1, ctx),
    // private from sort
    traverseQuerySort(visitor$2, ctx),
    // passwords from filters
    traverseQuerySort(visitor$3, ctx),
    // keys for empty non-scalar values
    traverseQuerySort(({ key, attribute, value, path }) => {
      if ([ID_ATTRIBUTE$1, DOC_ID_ATTRIBUTE$1].includes(key)) {
        return;
      }
      if (!isScalarAttribute(attribute) && fp.isEmpty(value)) {
        throwInvalidParam({ key, path: path.attribute });
      }
    }, ctx)
  )(sort2);
});
const defaultValidateFields = fp.curry((ctx, fields2) => {
  if (!ctx.schema) {
    throw new Error("Missing schema in defaultValidateFields");
  }
  return pipe(
    // Only allow scalar attributes
    traverseQueryFields(({ key, attribute, path }) => {
      if ([ID_ATTRIBUTE$1, DOC_ID_ATTRIBUTE$1].includes(key)) {
        return;
      }
      if (fp.isNil(attribute) || !isScalarAttribute(attribute)) {
        throwInvalidParam({ key, path: path.attribute });
      }
    }, ctx),
    // private fields
    traverseQueryFields(visitor$2, ctx),
    // password fields
    traverseQueryFields(visitor$3, ctx)
  )(fields2);
});
const defaultValidatePopulate = fp.curry((ctx, populate2) => {
  if (!ctx.schema) {
    throw new Error("Missing schema in defaultValidatePopulate");
  }
  return pipe(
    traverseQueryPopulate(async ({ key, value, schema, attribute, getModel }, { set }) => {
      if (attribute) {
        return;
      }
      if (key === "sort") {
        set(
          key,
          await defaultValidateSort(
            {
              schema,
              getModel
            },
            value
          )
        );
      }
      if (key === "filters") {
        set(
          key,
          await defaultValidateFilters(
            {
              schema,
              getModel
            },
            value
          )
        );
      }
      if (key === "fields") {
        set(
          key,
          await defaultValidateFields(
            {
              schema,
              getModel
            },
            value
          )
        );
      }
      if (key === "populate") {
        set(
          key,
          await defaultValidatePopulate(
            {
              schema,
              getModel
            },
            value
          )
        );
      }
    }, ctx),
    // Remove private fields
    traverseQueryPopulate(visitor$2, ctx)
  )(populate2);
});
const validators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defaultValidateFields,
  defaultValidateFilters,
  defaultValidatePopulate,
  defaultValidateSort,
  throwPasswords
}, Symbol.toStringTag, { value: "Module" }));
const { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE } = constants$1;
const createAPIValidators = (opts) => {
  const { getModel } = opts || {};
  const validateInput = async (data, schema, { auth } = {}) => {
    if (!schema) {
      throw new Error("Missing schema in validateInput");
    }
    if (fp.isArray(data)) {
      await Promise.all(data.map((entry) => validateInput(entry, schema, { auth })));
      return;
    }
    const nonWritableAttributes = getNonWritableAttributes(schema);
    const transforms = [
      (data2) => {
        if (fp.isObject(data2)) {
          if (ID_ATTRIBUTE in data2) {
            throwInvalidParam({ key: ID_ATTRIBUTE });
          }
          if (DOC_ID_ATTRIBUTE in data2) {
            throwInvalidParam({ key: DOC_ID_ATTRIBUTE });
          }
        }
      },
      // non-writable attributes
      traverseEntity$1(throwRestrictedFields(nonWritableAttributes), { schema, getModel })
    ];
    if (auth) {
      transforms.push(
        traverseEntity$1(throwRestrictedRelations(auth), {
          schema,
          getModel
        })
      );
    }
    opts?.validators?.input?.forEach((validator) => transforms.push(validator(schema)));
    await pipe(...transforms)(data);
  };
  const validateQuery = async (query, schema, { auth } = {}) => {
    if (!schema) {
      throw new Error("Missing schema in validateQuery");
    }
    const { filters: filters2, sort: sort2, fields: fields2, populate: populate2 } = query;
    if (filters2) {
      await validateFilters(filters2, schema, { auth });
    }
    if (sort2) {
      await validateSort(sort2, schema, { auth });
    }
    if (fields2) {
      await validateFields(fields2, schema);
    }
    if (populate2 && populate2 !== "*") {
      await validatePopulate(populate2, schema);
    }
  };
  const validateFilters = async (filters2, schema, { auth } = {}) => {
    if (!schema) {
      throw new Error("Missing schema in validateFilters");
    }
    if (fp.isArray(filters2)) {
      await Promise.all(filters2.map((filter) => validateFilters(filter, schema, { auth })));
      return;
    }
    const transforms = [defaultValidateFilters({ schema, getModel })];
    if (auth) {
      transforms.push(
        traverseQueryFilters(throwRestrictedRelations(auth), {
          schema,
          getModel
        })
      );
    }
    await pipe(...transforms)(filters2);
  };
  const validateSort = async (sort2, schema, { auth } = {}) => {
    if (!schema) {
      throw new Error("Missing schema in validateSort");
    }
    const transforms = [defaultValidateSort({ schema, getModel })];
    if (auth) {
      transforms.push(
        traverseQuerySort(throwRestrictedRelations(auth), {
          schema,
          getModel
        })
      );
    }
    await pipe(...transforms)(sort2);
  };
  const validateFields = async (fields2, schema) => {
    if (!schema) {
      throw new Error("Missing schema in validateFields");
    }
    const transforms = [defaultValidateFields({ schema, getModel })];
    await pipe(...transforms)(fields2);
  };
  const validatePopulate = async (populate2, schema, { auth } = {}) => {
    if (!schema) {
      throw new Error("Missing schema in sanitizePopulate");
    }
    const transforms = [defaultValidatePopulate({ schema, getModel })];
    if (auth) {
      transforms.push(
        traverseQueryPopulate(throwRestrictedRelations(auth), {
          schema,
          getModel
        })
      );
    }
    await pipe(...transforms)(populate2);
  };
  return {
    input: validateInput,
    query: validateQuery,
    filters: validateFilters,
    sort: validateSort,
    fields: validateFields,
    populate: validatePopulate
  };
};
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createAPIValidators,
  validators,
  visitors: index$1
}, Symbol.toStringTag, { value: "Module" }));
const STRAPI_DEFAULTS = {
  offset: {
    start: 0,
    limit: 10
  },
  page: {
    page: 1,
    pageSize: 10
  }
};
const paginationAttributes = ["start", "limit", "page", "pageSize"];
const withMaxLimit = (limit, maxLimit = -1) => {
  if (maxLimit === -1 || limit < maxLimit) {
    return limit;
  }
  return maxLimit;
};
const ensureMinValues = ({ start, limit }) => ({
  start: Math.max(start, 0),
  limit: limit === -1 ? limit : Math.max(limit, 1)
});
const ensureMaxValues = (maxLimit = -1) => ({ start, limit }) => ({
  start,
  limit: withMaxLimit(limit, maxLimit)
});
const withNoLimit = (pagination2, maxLimit = -1) => ({
  ...pagination2,
  limit: pagination2.limit === -1 ? maxLimit : pagination2.limit
});
const withDefaultPagination = (args, { defaults = {}, maxLimit = -1 } = {}) => {
  const defaultValues = fp.merge(STRAPI_DEFAULTS, defaults);
  const usePagePagination = !fp.isNil(args.page) || !fp.isNil(args.pageSize);
  const useOffsetPagination = !fp.isNil(args.start) || !fp.isNil(args.limit);
  const ensureValidValues = fp.pipe(ensureMinValues, ensureMaxValues(maxLimit));
  if (!usePagePagination && !useOffsetPagination) {
    return fp.merge(args, ensureValidValues(defaultValues.offset));
  }
  if (usePagePagination && useOffsetPagination) {
    throw new PaginationError("Cannot use both page & offset pagination in the same query");
  }
  const pagination2 = {
    start: 0,
    limit: 0
  };
  if (useOffsetPagination) {
    const { start, limit } = fp.merge(defaultValues.offset, args);
    Object.assign(pagination2, { start, limit });
  }
  if (usePagePagination) {
    const { page, pageSize } = fp.merge(defaultValues.page, {
      ...args,
      pageSize: Math.max(1, args.pageSize ?? 0)
    });
    Object.assign(pagination2, {
      start: (page - 1) * pageSize,
      limit: pageSize
    });
  }
  Object.assign(pagination2, withNoLimit(pagination2, maxLimit));
  const replacePaginationAttributes = fp.pipe(
    // Remove pagination attributes
    fp.omit(paginationAttributes),
    // Merge the object with the new pagination + ensure minimum & maximum values
    fp.merge(ensureValidValues(pagination2))
  );
  return replacePaginationAttributes(args);
};
const pagination = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  withDefaultPagination
}, Symbol.toStringTag, { value: "Module" }));
const SUPPORTED_PACKAGE_MANAGERS = ["npm", "yarn"];
const DEFAULT_PACKAGE_MANAGER = "npm";
const getPreferred = async (pkgPath) => {
  const pm = await preferredPM__default.default(pkgPath);
  const hasPackageManager = pm !== void 0;
  if (!hasPackageManager) {
    throw new Error(`Couldn't find a package manager in your project.`);
  }
  const isPackageManagerSupported = SUPPORTED_PACKAGE_MANAGERS.includes(pm.name);
  if (!isPackageManagerSupported) {
    process.emitWarning(
      `We detected your package manager (${pm.name} v${pm.version}), but it's not officially supported by Strapi yet. Defaulting to npm instead.`
    );
    return DEFAULT_PACKAGE_MANAGER;
  }
  return pm.name;
};
const installDependencies = (path, packageManager2, options = {}) => {
  return execa__default.default(packageManager2, ["install"], { ...options, cwd: path, stdin: "ignore" });
};
const packageManager = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getPreferred,
  installDependencies
}, Symbol.toStringTag, { value: "Module" }));
const createStrictInterpolationRegExp = (allowedVariableNames, flags) => {
  const oneOfVariables = allowedVariableNames.join("|");
  return new RegExp(`<%=\\s*(${oneOfVariables})\\s*%>`, flags);
};
const createLooseInterpolationRegExp = (flags) => new RegExp(/<%=([\s\S]+?)%>/, flags);
const template = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLooseInterpolationRegExp,
  createStrictInterpolationRegExp
}, Symbol.toStringTag, { value: "Module" }));
const kbytesToBytes = (kbytes) => kbytes * 1e3;
const bytesToKbytes = (bytes) => Math.round(bytes / 1e3 * 100) / 100;
const bytesToHumanReadable = (bytes) => {
  const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB"];
  if (bytes === 0)
    return "0 Bytes";
  const i = parseInt(`${Math.floor(Math.log(bytes) / Math.log(1e3))}`, 10);
  return `${Math.round(bytes / 1e3 ** i)} ${sizes[i]}`;
};
const streamToBuffer = (stream) => new Promise((resolve, reject) => {
  const chunks = [];
  stream.on("data", (chunk) => {
    chunks.push(chunk);
  });
  stream.on("end", () => {
    resolve(Buffer.concat(chunks));
  });
  stream.on("error", reject);
});
const getStreamSize = (stream) => new Promise((resolve, reject) => {
  let size = 0;
  stream.on("data", (chunk) => {
    size += Buffer.byteLength(chunk);
  });
  stream.on("close", () => resolve(size));
  stream.on("error", reject);
  stream.resume();
});
function writableDiscardStream(options) {
  return new node_stream.Writable({
    ...options,
    write(chunk, encding, callback) {
      setImmediate(callback);
    }
  });
}
const file = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bytesToHumanReadable,
  bytesToKbytes,
  getStreamSize,
  kbytesToBytes,
  streamToBuffer,
  writableDiscardStream
}, Symbol.toStringTag, { value: "Module" }));
const createPolicy = (options) => {
  const { name = "unnamed", validator, handler } = options;
  const wrappedValidator = (config) => {
    if (validator) {
      try {
        validator(config);
      } catch (e) {
        throw new Error(`Invalid config passed to "${name}" policy.`);
      }
    }
  };
  return {
    name,
    validator: wrappedValidator,
    handler
  };
};
const createPolicyContext = (type, ctx) => {
  return Object.assign(
    {
      is: fp.eq(type),
      get type() {
        return type;
      }
    },
    ctx
  );
};
const policy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createPolicy,
  createPolicyContext
}, Symbol.toStringTag, { value: "Module" }));
const nameToSlug = (name, options = { separator: "-" }) => slugify__default.default(name, options);
const nameToCollectionName = (name) => slugify__default.default(name, { separator: "_" });
const toRegressedEnumValue = (value) => slugify__default.default(value, {
  decamelize: false,
  lowercase: false,
  separator: "_"
});
const getCommonPath = (...paths) => {
  const [segments, ...otherSegments] = paths.map((it) => ___default.default.split(it, "/"));
  return ___default.default.join(
    ___default.default.takeWhile(segments, (str, index2) => otherSegments.every((it) => it[index2] === str)),
    "/"
  );
};
const isEqual = (a, b) => String(a) === String(b);
const isCamelCase = (value) => /^[a-z][a-zA-Z0-9]+$/.test(value);
const isKebabCase = (value) => /^([a-z][a-z0-9]*)(-[a-z0-9]+)*$/.test(value);
const startsWithANumber = (value) => /^[0-9]/.test(value);
const joinBy = (joint, ...args) => {
  const trim = fp.trimChars(joint);
  const trimEnd = fp.trimCharsEnd(joint);
  const trimStart = fp.trimCharsStart(joint);
  return args.reduce((url, path, index2) => {
    if (args.length === 1)
      return path;
    if (index2 === 0)
      return trimEnd(path);
    if (index2 === args.length - 1)
      return url + joint + trimStart(path);
    return url + joint + trim(path);
  }, "");
};
const toKebabCase = (value) => _$1.kebabCase(value);
const strings = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getCommonPath,
  isCamelCase,
  isEqual,
  isKebabCase,
  joinBy,
  nameToCollectionName,
  nameToSlug,
  startsWithANumber,
  toKebabCase,
  toRegressedEnumValue
}, Symbol.toStringTag, { value: "Module" }));
const castIncludes = (arr, val, cast) => arr.map((val2) => cast(val2)).includes(cast(val));
const includesString = (arr, val) => castIncludes(arr, val, String);
const arrays = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  includesString
}, Symbol.toStringTag, { value: "Module" }));
const keysDeep = (obj, path = []) => !___default.default.isObject(obj) ? [path.join(".")] : ___default.default.reduce(
  obj,
  (acc, next, key) => ___default.default.concat(acc, keysDeep(next, [...path, key])),
  []
);
const objects = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  keysDeep
}, Symbol.toStringTag, { value: "Module" }));
const timestampCode = (date) => {
  const referDate = date ?? /* @__PURE__ */ new Date();
  return referDate.getTime().toString(36);
};
const dates = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  timestampCode
}, Symbol.toStringTag, { value: "Module" }));
const { toString } = Object.prototype;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
const symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
function printNumber(val) {
  if (val != +val)
    return "NaN";
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? "-0" : `${val}`;
}
function printSimpleValue(val, quoteStrings = false) {
  if (val == null || val === true || val === false)
    return `${val}`;
  if (typeof val === "number")
    return printNumber(val);
  if (typeof val === "string")
    return quoteStrings ? `"${val}"` : val;
  if (typeof val === "function")
    return `[Function ${val.name || "anonymous"}]`;
  if (typeof val === "symbol")
    return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
  const tag = toString.call(val).slice(8, -1);
  if (tag === "Date") {
    const v = val;
    return Number.isNaN(v.getTime()) ? `${v}` : v.toISOString();
  }
  if (tag === "Error" || val instanceof Error)
    return `[${errorToString.call(val)}]`;
  if (tag === "RegExp")
    return regExpToString.call(val);
  return null;
}
function printValue(value, quoteStrings) {
  const result = printSimpleValue(value, quoteStrings);
  if (result !== null)
    return result;
  return JSON.stringify(
    value,
    function replacer(key, value2) {
      const result2 = printSimpleValue(this[key], quoteStrings);
      if (result2 !== null)
        return result2;
      return value2;
    },
    2
  );
}
const strapiID = () => new StrapiIDSchema();
const isNotNilTest = (value) => !___default.default.isNil(value);
const isNotNullTest = (value) => !___default.default.isNull(value);
yup__namespace.addMethod(yup__namespace.mixed, "notNil", function isNotNill(msg = "${path} must be defined.") {
  return this.test("defined", msg, isNotNilTest);
});
yup__namespace.addMethod(yup__namespace.mixed, "notNull", function isNotNull(msg = "${path} cannot be null.") {
  return this.test("defined", msg, isNotNullTest);
});
yup__namespace.addMethod(yup__namespace.mixed, "isFunction", function isFunction(message = "${path} is not a function") {
  return this.test(
    "is a function",
    message,
    (value) => ___default.default.isUndefined(value) || ___default.default.isFunction(value)
  );
});
yup__namespace.addMethod(
  yup__namespace.string,
  "isCamelCase",
  function isCamelCase$1(message = "${path} is not in camel case (anExampleOfCamelCase)") {
    return this.test(
      "is in camelCase",
      message,
      (value) => value ? isCamelCase(value) : true
    );
  }
);
yup__namespace.addMethod(
  yup__namespace.string,
  "isKebabCase",
  function isKebabCase$1(message = "${path} is not in kebab case (an-example-of-kebab-case)") {
    return this.test(
      "is in kebab-case",
      message,
      (value) => value ? isKebabCase(value) : true
    );
  }
);
yup__namespace.addMethod(
  yup__namespace.object,
  "onlyContainsFunctions",
  function onlyContainsFunctions(message = "${path} contains values that are not functions") {
    return this.test(
      "only contains functions",
      message,
      (value) => ___default.default.isUndefined(value) || value && Object.values(value).every(___default.default.isFunction)
    );
  }
);
yup__namespace.addMethod(
  yup__namespace.array,
  "uniqueProperty",
  function uniqueProperty(propertyName, message) {
    return this.test("unique", message, function unique(list) {
      const errors2 = [];
      list?.forEach((element, index2) => {
        const sameElements = list.filter(
          (e) => fp.get(propertyName, e) === fp.get(propertyName, element)
        );
        if (sameElements.length > 1) {
          errors2.push(
            this.createError({
              path: `${this.path}[${index2}].${propertyName}`,
              message
            })
          );
        }
      });
      if (errors2.length) {
        throw new yup__namespace.ValidationError(errors2);
      }
      return true;
    });
  }
);
class StrapiIDSchema extends yup__namespace.MixedSchema {
  constructor() {
    super({ type: "strapiID" });
  }
  _typeCheck(value) {
    return typeof value === "string" || fp.isNumber(value) && fp.isInteger(value) && value >= 0;
  }
}
yup__namespace.setLocale({
  mixed: {
    notType(options) {
      const { path, type, value, originalValue } = options;
      const isCast = originalValue != null && originalValue !== value;
      const msg = `${path} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`${isCast ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : "."}`;
      return msg;
    }
  }
});
const yup = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  StrapiIDSchema,
  strapiID
}, [yup__namespace]);
const MANY_RELATIONS = ["oneToMany", "manyToMany"];
const getRelationalFields = (contentType) => {
  return Object.keys(contentType.attributes).filter((attributeName) => {
    return contentType.attributes[attributeName].type === "relation";
  });
};
const isOneToAny = (attribute) => isRelationalAttribute(attribute) && ["oneToOne", "oneToMany"].includes(attribute.relation);
const isManyToAny = (attribute) => isRelationalAttribute(attribute) && ["manyToMany", "manyToOne"].includes(attribute.relation);
const isAnyToOne = (attribute) => isRelationalAttribute(attribute) && ["oneToOne", "manyToOne"].includes(attribute.relation);
const isAnyToMany = (attribute) => isRelationalAttribute(attribute) && ["oneToMany", "manyToMany"].includes(attribute.relation);
const constants = {
  MANY_RELATIONS
};
const relations = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  constants,
  getRelationalFields,
  isAnyToMany,
  isAnyToOne,
  isManyToAny,
  isOneToAny
}, Symbol.toStringTag, { value: "Module" }));
exports.arrays = arrays;
exports.async = async;
exports.contentTypes = contentTypes;
exports.dates = dates;
exports.env = env;
exports.errors = errors;
exports.file = file;
exports.hooks = hooks;
exports.importDefault = importDefault;
exports.isOperator = isOperator;
exports.isOperatorOfType = isOperatorOfType;
exports.machineID = machineId;
exports.objects = objects;
exports.packageManager = packageManager;
exports.pagination = pagination;
exports.parseType = parseType;
exports.policy = policy;
exports.providerFactory = providerFactory;
exports.queryParams = convertQueryParams;
exports.relations = relations;
exports.sanitize = index$2;
exports.setCreatorFields = setCreatorFields;
exports.strings = strings;
exports.template = template;
exports.traverse = index$3;
exports.traverseEntity = traverseEntity$1;
exports.validate = index;
exports.validateYupSchema = validateYupSchema;
exports.validateYupSchemaSync = validateYupSchemaSync;
exports.yup = yup;
//# sourceMappingURL=index.js.map
